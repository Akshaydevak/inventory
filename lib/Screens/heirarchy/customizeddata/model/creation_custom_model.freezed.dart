// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'creation_custom_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

CustomCreationtModel _$CustomCreationtModelFromJson(Map<String, dynamic> json) {
  return _CustomCreationtModel.fromJson(json);
}

/// @nodoc
class _$CustomCreationtModelTearOff {
  const _$CustomCreationtModelTearOff();

  _CustomCreationtModel call(
      {double? vat,
      double? height,
      double? width,
      double? length,
      double? weight,
      @JsonKey(name: "mapping_place_id")
          String? mappingPlaceId,
      @JsonKey(name: "minimum_gp")
          double? minimumGp,
      @JsonKey(name: "average_gp")
          double? averageGp,
      @JsonKey(name: "maximum_gp")
          double? maximumGp,
      @JsonKey(name: "excess_tax")
          double? excesstax,
      @JsonKey(name: "return_type")
          String? returnType,
      @JsonKey(name: "return_time")
          int? returnTime,
      @JsonKey(name: "weight_uom_id")
          double? weightUomId,
      @JsonKey(name: "targeted_gp")
          double? targetdGp,
      @JsonKey(name: "group_id")
          int? groupId,
      @JsonKey(name: "is_active", defaultValue: false)
          bool? isActive,
      @JsonKey(name: "need_multiple_integration", defaultValue: false)
          bool? needMultipleIntgration}) {
    return _CustomCreationtModel(
      vat: vat,
      height: height,
      width: width,
      length: length,
      weight: weight,
      mappingPlaceId: mappingPlaceId,
      minimumGp: minimumGp,
      averageGp: averageGp,
      maximumGp: maximumGp,
      excesstax: excesstax,
      returnType: returnType,
      returnTime: returnTime,
      weightUomId: weightUomId,
      targetdGp: targetdGp,
      groupId: groupId,
      isActive: isActive,
      needMultipleIntgration: needMultipleIntgration,
    );
  }

  CustomCreationtModel fromJson(Map<String, Object> json) {
    return CustomCreationtModel.fromJson(json);
  }
}

/// @nodoc
const $CustomCreationtModel = _$CustomCreationtModelTearOff();

/// @nodoc
mixin _$CustomCreationtModel {
  double? get vat => throw _privateConstructorUsedError;
  double? get height => throw _privateConstructorUsedError;
  double? get width => throw _privateConstructorUsedError;
  double? get length => throw _privateConstructorUsedError;
  double? get weight => throw _privateConstructorUsedError;
  @JsonKey(name: "mapping_place_id")
  String? get mappingPlaceId => throw _privateConstructorUsedError;
  @JsonKey(name: "minimum_gp")
  double? get minimumGp => throw _privateConstructorUsedError;
  @JsonKey(name: "average_gp")
  double? get averageGp => throw _privateConstructorUsedError;
  @JsonKey(name: "maximum_gp")
  double? get maximumGp => throw _privateConstructorUsedError;
  @JsonKey(name: "excess_tax")
  double? get excesstax => throw _privateConstructorUsedError;
  @JsonKey(name: "return_type")
  String? get returnType => throw _privateConstructorUsedError;
  @JsonKey(name: "return_time")
  int? get returnTime => throw _privateConstructorUsedError;
  @JsonKey(name: "weight_uom_id")
  double? get weightUomId => throw _privateConstructorUsedError;
  @JsonKey(name: "targeted_gp")
  double? get targetdGp => throw _privateConstructorUsedError;
  @JsonKey(name: "group_id")
  int? get groupId => throw _privateConstructorUsedError;
  @JsonKey(name: "is_active", defaultValue: false)
  bool? get isActive => throw _privateConstructorUsedError;
  @JsonKey(name: "need_multiple_integration", defaultValue: false)
  bool? get needMultipleIntgration => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CustomCreationtModelCopyWith<CustomCreationtModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomCreationtModelCopyWith<$Res> {
  factory $CustomCreationtModelCopyWith(CustomCreationtModel value,
          $Res Function(CustomCreationtModel) then) =
      _$CustomCreationtModelCopyWithImpl<$Res>;
  $Res call(
      {double? vat,
      double? height,
      double? width,
      double? length,
      double? weight,
      @JsonKey(name: "mapping_place_id")
          String? mappingPlaceId,
      @JsonKey(name: "minimum_gp")
          double? minimumGp,
      @JsonKey(name: "average_gp")
          double? averageGp,
      @JsonKey(name: "maximum_gp")
          double? maximumGp,
      @JsonKey(name: "excess_tax")
          double? excesstax,
      @JsonKey(name: "return_type")
          String? returnType,
      @JsonKey(name: "return_time")
          int? returnTime,
      @JsonKey(name: "weight_uom_id")
          double? weightUomId,
      @JsonKey(name: "targeted_gp")
          double? targetdGp,
      @JsonKey(name: "group_id")
          int? groupId,
      @JsonKey(name: "is_active", defaultValue: false)
          bool? isActive,
      @JsonKey(name: "need_multiple_integration", defaultValue: false)
          bool? needMultipleIntgration});
}

/// @nodoc
class _$CustomCreationtModelCopyWithImpl<$Res>
    implements $CustomCreationtModelCopyWith<$Res> {
  _$CustomCreationtModelCopyWithImpl(this._value, this._then);

  final CustomCreationtModel _value;
  // ignore: unused_field
  final $Res Function(CustomCreationtModel) _then;

  @override
  $Res call({
    Object? vat = freezed,
    Object? height = freezed,
    Object? width = freezed,
    Object? length = freezed,
    Object? weight = freezed,
    Object? mappingPlaceId = freezed,
    Object? minimumGp = freezed,
    Object? averageGp = freezed,
    Object? maximumGp = freezed,
    Object? excesstax = freezed,
    Object? returnType = freezed,
    Object? returnTime = freezed,
    Object? weightUomId = freezed,
    Object? targetdGp = freezed,
    Object? groupId = freezed,
    Object? isActive = freezed,
    Object? needMultipleIntgration = freezed,
  }) {
    return _then(_value.copyWith(
      vat: vat == freezed
          ? _value.vat
          : vat // ignore: cast_nullable_to_non_nullable
              as double?,
      height: height == freezed
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      width: width == freezed
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      length: length == freezed
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as double?,
      weight: weight == freezed
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double?,
      mappingPlaceId: mappingPlaceId == freezed
          ? _value.mappingPlaceId
          : mappingPlaceId // ignore: cast_nullable_to_non_nullable
              as String?,
      minimumGp: minimumGp == freezed
          ? _value.minimumGp
          : minimumGp // ignore: cast_nullable_to_non_nullable
              as double?,
      averageGp: averageGp == freezed
          ? _value.averageGp
          : averageGp // ignore: cast_nullable_to_non_nullable
              as double?,
      maximumGp: maximumGp == freezed
          ? _value.maximumGp
          : maximumGp // ignore: cast_nullable_to_non_nullable
              as double?,
      excesstax: excesstax == freezed
          ? _value.excesstax
          : excesstax // ignore: cast_nullable_to_non_nullable
              as double?,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String?,
      returnTime: returnTime == freezed
          ? _value.returnTime
          : returnTime // ignore: cast_nullable_to_non_nullable
              as int?,
      weightUomId: weightUomId == freezed
          ? _value.weightUomId
          : weightUomId // ignore: cast_nullable_to_non_nullable
              as double?,
      targetdGp: targetdGp == freezed
          ? _value.targetdGp
          : targetdGp // ignore: cast_nullable_to_non_nullable
              as double?,
      groupId: groupId == freezed
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: isActive == freezed
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      needMultipleIntgration: needMultipleIntgration == freezed
          ? _value.needMultipleIntgration
          : needMultipleIntgration // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
abstract class _$CustomCreationtModelCopyWith<$Res>
    implements $CustomCreationtModelCopyWith<$Res> {
  factory _$CustomCreationtModelCopyWith(_CustomCreationtModel value,
          $Res Function(_CustomCreationtModel) then) =
      __$CustomCreationtModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {double? vat,
      double? height,
      double? width,
      double? length,
      double? weight,
      @JsonKey(name: "mapping_place_id")
          String? mappingPlaceId,
      @JsonKey(name: "minimum_gp")
          double? minimumGp,
      @JsonKey(name: "average_gp")
          double? averageGp,
      @JsonKey(name: "maximum_gp")
          double? maximumGp,
      @JsonKey(name: "excess_tax")
          double? excesstax,
      @JsonKey(name: "return_type")
          String? returnType,
      @JsonKey(name: "return_time")
          int? returnTime,
      @JsonKey(name: "weight_uom_id")
          double? weightUomId,
      @JsonKey(name: "targeted_gp")
          double? targetdGp,
      @JsonKey(name: "group_id")
          int? groupId,
      @JsonKey(name: "is_active", defaultValue: false)
          bool? isActive,
      @JsonKey(name: "need_multiple_integration", defaultValue: false)
          bool? needMultipleIntgration});
}

/// @nodoc
class __$CustomCreationtModelCopyWithImpl<$Res>
    extends _$CustomCreationtModelCopyWithImpl<$Res>
    implements _$CustomCreationtModelCopyWith<$Res> {
  __$CustomCreationtModelCopyWithImpl(
      _CustomCreationtModel _value, $Res Function(_CustomCreationtModel) _then)
      : super(_value, (v) => _then(v as _CustomCreationtModel));

  @override
  _CustomCreationtModel get _value => super._value as _CustomCreationtModel;

  @override
  $Res call({
    Object? vat = freezed,
    Object? height = freezed,
    Object? width = freezed,
    Object? length = freezed,
    Object? weight = freezed,
    Object? mappingPlaceId = freezed,
    Object? minimumGp = freezed,
    Object? averageGp = freezed,
    Object? maximumGp = freezed,
    Object? excesstax = freezed,
    Object? returnType = freezed,
    Object? returnTime = freezed,
    Object? weightUomId = freezed,
    Object? targetdGp = freezed,
    Object? groupId = freezed,
    Object? isActive = freezed,
    Object? needMultipleIntgration = freezed,
  }) {
    return _then(_CustomCreationtModel(
      vat: vat == freezed
          ? _value.vat
          : vat // ignore: cast_nullable_to_non_nullable
              as double?,
      height: height == freezed
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      width: width == freezed
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      length: length == freezed
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as double?,
      weight: weight == freezed
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double?,
      mappingPlaceId: mappingPlaceId == freezed
          ? _value.mappingPlaceId
          : mappingPlaceId // ignore: cast_nullable_to_non_nullable
              as String?,
      minimumGp: minimumGp == freezed
          ? _value.minimumGp
          : minimumGp // ignore: cast_nullable_to_non_nullable
              as double?,
      averageGp: averageGp == freezed
          ? _value.averageGp
          : averageGp // ignore: cast_nullable_to_non_nullable
              as double?,
      maximumGp: maximumGp == freezed
          ? _value.maximumGp
          : maximumGp // ignore: cast_nullable_to_non_nullable
              as double?,
      excesstax: excesstax == freezed
          ? _value.excesstax
          : excesstax // ignore: cast_nullable_to_non_nullable
              as double?,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String?,
      returnTime: returnTime == freezed
          ? _value.returnTime
          : returnTime // ignore: cast_nullable_to_non_nullable
              as int?,
      weightUomId: weightUomId == freezed
          ? _value.weightUomId
          : weightUomId // ignore: cast_nullable_to_non_nullable
              as double?,
      targetdGp: targetdGp == freezed
          ? _value.targetdGp
          : targetdGp // ignore: cast_nullable_to_non_nullable
              as double?,
      groupId: groupId == freezed
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: isActive == freezed
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      needMultipleIntgration: needMultipleIntgration == freezed
          ? _value.needMultipleIntgration
          : needMultipleIntgration // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CustomCreationtModel implements _CustomCreationtModel {
  const _$_CustomCreationtModel(
      {this.vat,
      this.height,
      this.width,
      this.length,
      this.weight,
      @JsonKey(name: "mapping_place_id")
          this.mappingPlaceId,
      @JsonKey(name: "minimum_gp")
          this.minimumGp,
      @JsonKey(name: "average_gp")
          this.averageGp,
      @JsonKey(name: "maximum_gp")
          this.maximumGp,
      @JsonKey(name: "excess_tax")
          this.excesstax,
      @JsonKey(name: "return_type")
          this.returnType,
      @JsonKey(name: "return_time")
          this.returnTime,
      @JsonKey(name: "weight_uom_id")
          this.weightUomId,
      @JsonKey(name: "targeted_gp")
          this.targetdGp,
      @JsonKey(name: "group_id")
          this.groupId,
      @JsonKey(name: "is_active", defaultValue: false)
          this.isActive,
      @JsonKey(name: "need_multiple_integration", defaultValue: false)
          this.needMultipleIntgration});

  factory _$_CustomCreationtModel.fromJson(Map<String, dynamic> json) =>
      _$$_CustomCreationtModelFromJson(json);

  @override
  final double? vat;
  @override
  final double? height;
  @override
  final double? width;
  @override
  final double? length;
  @override
  final double? weight;
  @override
  @JsonKey(name: "mapping_place_id")
  final String? mappingPlaceId;
  @override
  @JsonKey(name: "minimum_gp")
  final double? minimumGp;
  @override
  @JsonKey(name: "average_gp")
  final double? averageGp;
  @override
  @JsonKey(name: "maximum_gp")
  final double? maximumGp;
  @override
  @JsonKey(name: "excess_tax")
  final double? excesstax;
  @override
  @JsonKey(name: "return_type")
  final String? returnType;
  @override
  @JsonKey(name: "return_time")
  final int? returnTime;
  @override
  @JsonKey(name: "weight_uom_id")
  final double? weightUomId;
  @override
  @JsonKey(name: "targeted_gp")
  final double? targetdGp;
  @override
  @JsonKey(name: "group_id")
  final int? groupId;
  @override
  @JsonKey(name: "is_active", defaultValue: false)
  final bool? isActive;
  @override
  @JsonKey(name: "need_multiple_integration", defaultValue: false)
  final bool? needMultipleIntgration;

  @override
  String toString() {
    return 'CustomCreationtModel(vat: $vat, height: $height, width: $width, length: $length, weight: $weight, mappingPlaceId: $mappingPlaceId, minimumGp: $minimumGp, averageGp: $averageGp, maximumGp: $maximumGp, excesstax: $excesstax, returnType: $returnType, returnTime: $returnTime, weightUomId: $weightUomId, targetdGp: $targetdGp, groupId: $groupId, isActive: $isActive, needMultipleIntgration: $needMultipleIntgration)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _CustomCreationtModel &&
            (identical(other.vat, vat) ||
                const DeepCollectionEquality().equals(other.vat, vat)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.length, length) ||
                const DeepCollectionEquality().equals(other.length, length)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.mappingPlaceId, mappingPlaceId) ||
                const DeepCollectionEquality()
                    .equals(other.mappingPlaceId, mappingPlaceId)) &&
            (identical(other.minimumGp, minimumGp) ||
                const DeepCollectionEquality()
                    .equals(other.minimumGp, minimumGp)) &&
            (identical(other.averageGp, averageGp) ||
                const DeepCollectionEquality()
                    .equals(other.averageGp, averageGp)) &&
            (identical(other.maximumGp, maximumGp) ||
                const DeepCollectionEquality()
                    .equals(other.maximumGp, maximumGp)) &&
            (identical(other.excesstax, excesstax) ||
                const DeepCollectionEquality()
                    .equals(other.excesstax, excesstax)) &&
            (identical(other.returnType, returnType) ||
                const DeepCollectionEquality()
                    .equals(other.returnType, returnType)) &&
            (identical(other.returnTime, returnTime) ||
                const DeepCollectionEquality()
                    .equals(other.returnTime, returnTime)) &&
            (identical(other.weightUomId, weightUomId) ||
                const DeepCollectionEquality()
                    .equals(other.weightUomId, weightUomId)) &&
            (identical(other.targetdGp, targetdGp) ||
                const DeepCollectionEquality()
                    .equals(other.targetdGp, targetdGp)) &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.needMultipleIntgration, needMultipleIntgration) ||
                const DeepCollectionEquality().equals(
                    other.needMultipleIntgration, needMultipleIntgration)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(vat) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(length) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(mappingPlaceId) ^
      const DeepCollectionEquality().hash(minimumGp) ^
      const DeepCollectionEquality().hash(averageGp) ^
      const DeepCollectionEquality().hash(maximumGp) ^
      const DeepCollectionEquality().hash(excesstax) ^
      const DeepCollectionEquality().hash(returnType) ^
      const DeepCollectionEquality().hash(returnTime) ^
      const DeepCollectionEquality().hash(weightUomId) ^
      const DeepCollectionEquality().hash(targetdGp) ^
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(needMultipleIntgration);

  @JsonKey(ignore: true)
  @override
  _$CustomCreationtModelCopyWith<_CustomCreationtModel> get copyWith =>
      __$CustomCreationtModelCopyWithImpl<_CustomCreationtModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CustomCreationtModelToJson(this);
  }
}

abstract class _CustomCreationtModel implements CustomCreationtModel {
  const factory _CustomCreationtModel(
      {double? vat,
      double? height,
      double? width,
      double? length,
      double? weight,
      @JsonKey(name: "mapping_place_id")
          String? mappingPlaceId,
      @JsonKey(name: "minimum_gp")
          double? minimumGp,
      @JsonKey(name: "average_gp")
          double? averageGp,
      @JsonKey(name: "maximum_gp")
          double? maximumGp,
      @JsonKey(name: "excess_tax")
          double? excesstax,
      @JsonKey(name: "return_type")
          String? returnType,
      @JsonKey(name: "return_time")
          int? returnTime,
      @JsonKey(name: "weight_uom_id")
          double? weightUomId,
      @JsonKey(name: "targeted_gp")
          double? targetdGp,
      @JsonKey(name: "group_id")
          int? groupId,
      @JsonKey(name: "is_active", defaultValue: false)
          bool? isActive,
      @JsonKey(name: "need_multiple_integration", defaultValue: false)
          bool? needMultipleIntgration}) = _$_CustomCreationtModel;

  factory _CustomCreationtModel.fromJson(Map<String, dynamic> json) =
      _$_CustomCreationtModel.fromJson;

  @override
  double? get vat => throw _privateConstructorUsedError;
  @override
  double? get height => throw _privateConstructorUsedError;
  @override
  double? get width => throw _privateConstructorUsedError;
  @override
  double? get length => throw _privateConstructorUsedError;
  @override
  double? get weight => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "mapping_place_id")
  String? get mappingPlaceId => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "minimum_gp")
  double? get minimumGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "average_gp")
  double? get averageGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "maximum_gp")
  double? get maximumGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "excess_tax")
  double? get excesstax => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "return_type")
  String? get returnType => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "return_time")
  int? get returnTime => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "weight_uom_id")
  double? get weightUomId => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "targeted_gp")
  double? get targetdGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "group_id")
  int? get groupId => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "is_active", defaultValue: false)
  bool? get isActive => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "need_multiple_integration", defaultValue: false)
  bool? get needMultipleIntgration => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$CustomCreationtModelCopyWith<_CustomCreationtModel> get copyWith =>
      throw _privateConstructorUsedError;
}

ReadCustomModel _$ReadCustomModelFromJson(Map<String, dynamic> json) {
  return _ReadCustomModel.fromJson(json);
}

/// @nodoc
class _$ReadCustomModelTearOff {
  const _$ReadCustomModelTearOff();

  _ReadCustomModel call(
      {@JsonKey(name: "return_type") List<String>? returnType,
      @JsonKey(name: "group_custom_data") GroupCustomData? groupCustomdata}) {
    return _ReadCustomModel(
      returnType: returnType,
      groupCustomdata: groupCustomdata,
    );
  }

  ReadCustomModel fromJson(Map<String, Object> json) {
    return ReadCustomModel.fromJson(json);
  }
}

/// @nodoc
const $ReadCustomModel = _$ReadCustomModelTearOff();

/// @nodoc
mixin _$ReadCustomModel {
  @JsonKey(name: "return_type")
  List<String>? get returnType => throw _privateConstructorUsedError;
  @JsonKey(name: "group_custom_data")
  GroupCustomData? get groupCustomdata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ReadCustomModelCopyWith<ReadCustomModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReadCustomModelCopyWith<$Res> {
  factory $ReadCustomModelCopyWith(
          ReadCustomModel value, $Res Function(ReadCustomModel) then) =
      _$ReadCustomModelCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: "return_type") List<String>? returnType,
      @JsonKey(name: "group_custom_data") GroupCustomData? groupCustomdata});

  $GroupCustomDataCopyWith<$Res>? get groupCustomdata;
}

/// @nodoc
class _$ReadCustomModelCopyWithImpl<$Res>
    implements $ReadCustomModelCopyWith<$Res> {
  _$ReadCustomModelCopyWithImpl(this._value, this._then);

  final ReadCustomModel _value;
  // ignore: unused_field
  final $Res Function(ReadCustomModel) _then;

  @override
  $Res call({
    Object? returnType = freezed,
    Object? groupCustomdata = freezed,
  }) {
    return _then(_value.copyWith(
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      groupCustomdata: groupCustomdata == freezed
          ? _value.groupCustomdata
          : groupCustomdata // ignore: cast_nullable_to_non_nullable
              as GroupCustomData?,
    ));
  }

  @override
  $GroupCustomDataCopyWith<$Res>? get groupCustomdata {
    if (_value.groupCustomdata == null) {
      return null;
    }

    return $GroupCustomDataCopyWith<$Res>(_value.groupCustomdata!, (value) {
      return _then(_value.copyWith(groupCustomdata: value));
    });
  }
}

/// @nodoc
abstract class _$ReadCustomModelCopyWith<$Res>
    implements $ReadCustomModelCopyWith<$Res> {
  factory _$ReadCustomModelCopyWith(
          _ReadCustomModel value, $Res Function(_ReadCustomModel) then) =
      __$ReadCustomModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: "return_type") List<String>? returnType,
      @JsonKey(name: "group_custom_data") GroupCustomData? groupCustomdata});

  @override
  $GroupCustomDataCopyWith<$Res>? get groupCustomdata;
}

/// @nodoc
class __$ReadCustomModelCopyWithImpl<$Res>
    extends _$ReadCustomModelCopyWithImpl<$Res>
    implements _$ReadCustomModelCopyWith<$Res> {
  __$ReadCustomModelCopyWithImpl(
      _ReadCustomModel _value, $Res Function(_ReadCustomModel) _then)
      : super(_value, (v) => _then(v as _ReadCustomModel));

  @override
  _ReadCustomModel get _value => super._value as _ReadCustomModel;

  @override
  $Res call({
    Object? returnType = freezed,
    Object? groupCustomdata = freezed,
  }) {
    return _then(_ReadCustomModel(
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      groupCustomdata: groupCustomdata == freezed
          ? _value.groupCustomdata
          : groupCustomdata // ignore: cast_nullable_to_non_nullable
              as GroupCustomData?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ReadCustomModel implements _ReadCustomModel {
  const _$_ReadCustomModel(
      {@JsonKey(name: "return_type") this.returnType,
      @JsonKey(name: "group_custom_data") this.groupCustomdata});

  factory _$_ReadCustomModel.fromJson(Map<String, dynamic> json) =>
      _$$_ReadCustomModelFromJson(json);

  @override
  @JsonKey(name: "return_type")
  final List<String>? returnType;
  @override
  @JsonKey(name: "group_custom_data")
  final GroupCustomData? groupCustomdata;

  @override
  String toString() {
    return 'ReadCustomModel(returnType: $returnType, groupCustomdata: $groupCustomdata)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ReadCustomModel &&
            (identical(other.returnType, returnType) ||
                const DeepCollectionEquality()
                    .equals(other.returnType, returnType)) &&
            (identical(other.groupCustomdata, groupCustomdata) ||
                const DeepCollectionEquality()
                    .equals(other.groupCustomdata, groupCustomdata)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(returnType) ^
      const DeepCollectionEquality().hash(groupCustomdata);

  @JsonKey(ignore: true)
  @override
  _$ReadCustomModelCopyWith<_ReadCustomModel> get copyWith =>
      __$ReadCustomModelCopyWithImpl<_ReadCustomModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ReadCustomModelToJson(this);
  }
}

abstract class _ReadCustomModel implements ReadCustomModel {
  const factory _ReadCustomModel(
      {@JsonKey(name: "return_type")
          List<String>? returnType,
      @JsonKey(name: "group_custom_data")
          GroupCustomData? groupCustomdata}) = _$_ReadCustomModel;

  factory _ReadCustomModel.fromJson(Map<String, dynamic> json) =
      _$_ReadCustomModel.fromJson;

  @override
  @JsonKey(name: "return_type")
  List<String>? get returnType => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "group_custom_data")
  GroupCustomData? get groupCustomdata => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ReadCustomModelCopyWith<_ReadCustomModel> get copyWith =>
      throw _privateConstructorUsedError;
}

GroupCustomData _$GroupCustomDataFromJson(Map<String, dynamic> json) {
  return _GroupCustomData.fromJson(json);
}

/// @nodoc
class _$GroupCustomDataTearOff {
  const _$GroupCustomDataTearOff();

  _GroupCustomData call(
      {int? id,
      double? vat,
      String? code,
      Dimension? dimension,
      @JsonKey(name: "min_gp") double? minGp,
      @JsonKey(name: "avrg_gp") double? avrgGp,
      @JsonKey(name: "max_gp") double? maxGp,
      @JsonKey(name: "targeted_gp") double? targetedGp,
      @JsonKey(name: "excess_tax") double? excessTax,
      @JsonKey(name: "return_type") String? returntype,
      @JsonKey(name: "group_name") String? groupNmae,
      @JsonKey(name: "return_time") int? returnTime,
      @JsonKey(name: "weight_uom_id") int? weightUomId,
      @JsonKey(name: "is_active") bool? isActive,
      @JsonKey(name: "need_multiple_integration") bool? needMultipleIntegration,
      @JsonKey(name: "group_id") int? groupId}) {
    return _GroupCustomData(
      id: id,
      vat: vat,
      code: code,
      dimension: dimension,
      minGp: minGp,
      avrgGp: avrgGp,
      maxGp: maxGp,
      targetedGp: targetedGp,
      excessTax: excessTax,
      returntype: returntype,
      groupNmae: groupNmae,
      returnTime: returnTime,
      weightUomId: weightUomId,
      isActive: isActive,
      needMultipleIntegration: needMultipleIntegration,
      groupId: groupId,
    );
  }

  GroupCustomData fromJson(Map<String, Object> json) {
    return GroupCustomData.fromJson(json);
  }
}

/// @nodoc
const $GroupCustomData = _$GroupCustomDataTearOff();

/// @nodoc
mixin _$GroupCustomData {
  int? get id => throw _privateConstructorUsedError;
  double? get vat => throw _privateConstructorUsedError;
  String? get code => throw _privateConstructorUsedError;
  Dimension? get dimension => throw _privateConstructorUsedError;
  @JsonKey(name: "min_gp")
  double? get minGp => throw _privateConstructorUsedError;
  @JsonKey(name: "avrg_gp")
  double? get avrgGp => throw _privateConstructorUsedError;
  @JsonKey(name: "max_gp")
  double? get maxGp => throw _privateConstructorUsedError;
  @JsonKey(name: "targeted_gp")
  double? get targetedGp => throw _privateConstructorUsedError;
  @JsonKey(name: "excess_tax")
  double? get excessTax => throw _privateConstructorUsedError;
  @JsonKey(name: "return_type")
  String? get returntype => throw _privateConstructorUsedError;
  @JsonKey(name: "group_name")
  String? get groupNmae => throw _privateConstructorUsedError;
  @JsonKey(name: "return_time")
  int? get returnTime => throw _privateConstructorUsedError;
  @JsonKey(name: "weight_uom_id")
  int? get weightUomId => throw _privateConstructorUsedError;
  @JsonKey(name: "is_active")
  bool? get isActive => throw _privateConstructorUsedError;
  @JsonKey(name: "need_multiple_integration")
  bool? get needMultipleIntegration => throw _privateConstructorUsedError;
  @JsonKey(name: "group_id")
  int? get groupId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GroupCustomDataCopyWith<GroupCustomData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupCustomDataCopyWith<$Res> {
  factory $GroupCustomDataCopyWith(
          GroupCustomData value, $Res Function(GroupCustomData) then) =
      _$GroupCustomDataCopyWithImpl<$Res>;
  $Res call(
      {int? id,
      double? vat,
      String? code,
      Dimension? dimension,
      @JsonKey(name: "min_gp") double? minGp,
      @JsonKey(name: "avrg_gp") double? avrgGp,
      @JsonKey(name: "max_gp") double? maxGp,
      @JsonKey(name: "targeted_gp") double? targetedGp,
      @JsonKey(name: "excess_tax") double? excessTax,
      @JsonKey(name: "return_type") String? returntype,
      @JsonKey(name: "group_name") String? groupNmae,
      @JsonKey(name: "return_time") int? returnTime,
      @JsonKey(name: "weight_uom_id") int? weightUomId,
      @JsonKey(name: "is_active") bool? isActive,
      @JsonKey(name: "need_multiple_integration") bool? needMultipleIntegration,
      @JsonKey(name: "group_id") int? groupId});

  $DimensionCopyWith<$Res>? get dimension;
}

/// @nodoc
class _$GroupCustomDataCopyWithImpl<$Res>
    implements $GroupCustomDataCopyWith<$Res> {
  _$GroupCustomDataCopyWithImpl(this._value, this._then);

  final GroupCustomData _value;
  // ignore: unused_field
  final $Res Function(GroupCustomData) _then;

  @override
  $Res call({
    Object? id = freezed,
    Object? vat = freezed,
    Object? code = freezed,
    Object? dimension = freezed,
    Object? minGp = freezed,
    Object? avrgGp = freezed,
    Object? maxGp = freezed,
    Object? targetedGp = freezed,
    Object? excessTax = freezed,
    Object? returntype = freezed,
    Object? groupNmae = freezed,
    Object? returnTime = freezed,
    Object? weightUomId = freezed,
    Object? isActive = freezed,
    Object? needMultipleIntegration = freezed,
    Object? groupId = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      vat: vat == freezed
          ? _value.vat
          : vat // ignore: cast_nullable_to_non_nullable
              as double?,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      dimension: dimension == freezed
          ? _value.dimension
          : dimension // ignore: cast_nullable_to_non_nullable
              as Dimension?,
      minGp: minGp == freezed
          ? _value.minGp
          : minGp // ignore: cast_nullable_to_non_nullable
              as double?,
      avrgGp: avrgGp == freezed
          ? _value.avrgGp
          : avrgGp // ignore: cast_nullable_to_non_nullable
              as double?,
      maxGp: maxGp == freezed
          ? _value.maxGp
          : maxGp // ignore: cast_nullable_to_non_nullable
              as double?,
      targetedGp: targetedGp == freezed
          ? _value.targetedGp
          : targetedGp // ignore: cast_nullable_to_non_nullable
              as double?,
      excessTax: excessTax == freezed
          ? _value.excessTax
          : excessTax // ignore: cast_nullable_to_non_nullable
              as double?,
      returntype: returntype == freezed
          ? _value.returntype
          : returntype // ignore: cast_nullable_to_non_nullable
              as String?,
      groupNmae: groupNmae == freezed
          ? _value.groupNmae
          : groupNmae // ignore: cast_nullable_to_non_nullable
              as String?,
      returnTime: returnTime == freezed
          ? _value.returnTime
          : returnTime // ignore: cast_nullable_to_non_nullable
              as int?,
      weightUomId: weightUomId == freezed
          ? _value.weightUomId
          : weightUomId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: isActive == freezed
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      needMultipleIntegration: needMultipleIntegration == freezed
          ? _value.needMultipleIntegration
          : needMultipleIntegration // ignore: cast_nullable_to_non_nullable
              as bool?,
      groupId: groupId == freezed
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  @override
  $DimensionCopyWith<$Res>? get dimension {
    if (_value.dimension == null) {
      return null;
    }

    return $DimensionCopyWith<$Res>(_value.dimension!, (value) {
      return _then(_value.copyWith(dimension: value));
    });
  }
}

/// @nodoc
abstract class _$GroupCustomDataCopyWith<$Res>
    implements $GroupCustomDataCopyWith<$Res> {
  factory _$GroupCustomDataCopyWith(
          _GroupCustomData value, $Res Function(_GroupCustomData) then) =
      __$GroupCustomDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {int? id,
      double? vat,
      String? code,
      Dimension? dimension,
      @JsonKey(name: "min_gp") double? minGp,
      @JsonKey(name: "avrg_gp") double? avrgGp,
      @JsonKey(name: "max_gp") double? maxGp,
      @JsonKey(name: "targeted_gp") double? targetedGp,
      @JsonKey(name: "excess_tax") double? excessTax,
      @JsonKey(name: "return_type") String? returntype,
      @JsonKey(name: "group_name") String? groupNmae,
      @JsonKey(name: "return_time") int? returnTime,
      @JsonKey(name: "weight_uom_id") int? weightUomId,
      @JsonKey(name: "is_active") bool? isActive,
      @JsonKey(name: "need_multiple_integration") bool? needMultipleIntegration,
      @JsonKey(name: "group_id") int? groupId});

  @override
  $DimensionCopyWith<$Res>? get dimension;
}

/// @nodoc
class __$GroupCustomDataCopyWithImpl<$Res>
    extends _$GroupCustomDataCopyWithImpl<$Res>
    implements _$GroupCustomDataCopyWith<$Res> {
  __$GroupCustomDataCopyWithImpl(
      _GroupCustomData _value, $Res Function(_GroupCustomData) _then)
      : super(_value, (v) => _then(v as _GroupCustomData));

  @override
  _GroupCustomData get _value => super._value as _GroupCustomData;

  @override
  $Res call({
    Object? id = freezed,
    Object? vat = freezed,
    Object? code = freezed,
    Object? dimension = freezed,
    Object? minGp = freezed,
    Object? avrgGp = freezed,
    Object? maxGp = freezed,
    Object? targetedGp = freezed,
    Object? excessTax = freezed,
    Object? returntype = freezed,
    Object? groupNmae = freezed,
    Object? returnTime = freezed,
    Object? weightUomId = freezed,
    Object? isActive = freezed,
    Object? needMultipleIntegration = freezed,
    Object? groupId = freezed,
  }) {
    return _then(_GroupCustomData(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      vat: vat == freezed
          ? _value.vat
          : vat // ignore: cast_nullable_to_non_nullable
              as double?,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      dimension: dimension == freezed
          ? _value.dimension
          : dimension // ignore: cast_nullable_to_non_nullable
              as Dimension?,
      minGp: minGp == freezed
          ? _value.minGp
          : minGp // ignore: cast_nullable_to_non_nullable
              as double?,
      avrgGp: avrgGp == freezed
          ? _value.avrgGp
          : avrgGp // ignore: cast_nullable_to_non_nullable
              as double?,
      maxGp: maxGp == freezed
          ? _value.maxGp
          : maxGp // ignore: cast_nullable_to_non_nullable
              as double?,
      targetedGp: targetedGp == freezed
          ? _value.targetedGp
          : targetedGp // ignore: cast_nullable_to_non_nullable
              as double?,
      excessTax: excessTax == freezed
          ? _value.excessTax
          : excessTax // ignore: cast_nullable_to_non_nullable
              as double?,
      returntype: returntype == freezed
          ? _value.returntype
          : returntype // ignore: cast_nullable_to_non_nullable
              as String?,
      groupNmae: groupNmae == freezed
          ? _value.groupNmae
          : groupNmae // ignore: cast_nullable_to_non_nullable
              as String?,
      returnTime: returnTime == freezed
          ? _value.returnTime
          : returnTime // ignore: cast_nullable_to_non_nullable
              as int?,
      weightUomId: weightUomId == freezed
          ? _value.weightUomId
          : weightUomId // ignore: cast_nullable_to_non_nullable
              as int?,
      isActive: isActive == freezed
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      needMultipleIntegration: needMultipleIntegration == freezed
          ? _value.needMultipleIntegration
          : needMultipleIntegration // ignore: cast_nullable_to_non_nullable
              as bool?,
      groupId: groupId == freezed
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GroupCustomData implements _GroupCustomData {
  const _$_GroupCustomData(
      {this.id,
      this.vat,
      this.code,
      this.dimension,
      @JsonKey(name: "min_gp") this.minGp,
      @JsonKey(name: "avrg_gp") this.avrgGp,
      @JsonKey(name: "max_gp") this.maxGp,
      @JsonKey(name: "targeted_gp") this.targetedGp,
      @JsonKey(name: "excess_tax") this.excessTax,
      @JsonKey(name: "return_type") this.returntype,
      @JsonKey(name: "group_name") this.groupNmae,
      @JsonKey(name: "return_time") this.returnTime,
      @JsonKey(name: "weight_uom_id") this.weightUomId,
      @JsonKey(name: "is_active") this.isActive,
      @JsonKey(name: "need_multiple_integration") this.needMultipleIntegration,
      @JsonKey(name: "group_id") this.groupId});

  factory _$_GroupCustomData.fromJson(Map<String, dynamic> json) =>
      _$$_GroupCustomDataFromJson(json);

  @override
  final int? id;
  @override
  final double? vat;
  @override
  final String? code;
  @override
  final Dimension? dimension;
  @override
  @JsonKey(name: "min_gp")
  final double? minGp;
  @override
  @JsonKey(name: "avrg_gp")
  final double? avrgGp;
  @override
  @JsonKey(name: "max_gp")
  final double? maxGp;
  @override
  @JsonKey(name: "targeted_gp")
  final double? targetedGp;
  @override
  @JsonKey(name: "excess_tax")
  final double? excessTax;
  @override
  @JsonKey(name: "return_type")
  final String? returntype;
  @override
  @JsonKey(name: "group_name")
  final String? groupNmae;
  @override
  @JsonKey(name: "return_time")
  final int? returnTime;
  @override
  @JsonKey(name: "weight_uom_id")
  final int? weightUomId;
  @override
  @JsonKey(name: "is_active")
  final bool? isActive;
  @override
  @JsonKey(name: "need_multiple_integration")
  final bool? needMultipleIntegration;
  @override
  @JsonKey(name: "group_id")
  final int? groupId;

  @override
  String toString() {
    return 'GroupCustomData(id: $id, vat: $vat, code: $code, dimension: $dimension, minGp: $minGp, avrgGp: $avrgGp, maxGp: $maxGp, targetedGp: $targetedGp, excessTax: $excessTax, returntype: $returntype, groupNmae: $groupNmae, returnTime: $returnTime, weightUomId: $weightUomId, isActive: $isActive, needMultipleIntegration: $needMultipleIntegration, groupId: $groupId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GroupCustomData &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.vat, vat) ||
                const DeepCollectionEquality().equals(other.vat, vat)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.dimension, dimension) ||
                const DeepCollectionEquality()
                    .equals(other.dimension, dimension)) &&
            (identical(other.minGp, minGp) ||
                const DeepCollectionEquality().equals(other.minGp, minGp)) &&
            (identical(other.avrgGp, avrgGp) ||
                const DeepCollectionEquality().equals(other.avrgGp, avrgGp)) &&
            (identical(other.maxGp, maxGp) ||
                const DeepCollectionEquality().equals(other.maxGp, maxGp)) &&
            (identical(other.targetedGp, targetedGp) ||
                const DeepCollectionEquality()
                    .equals(other.targetedGp, targetedGp)) &&
            (identical(other.excessTax, excessTax) ||
                const DeepCollectionEquality()
                    .equals(other.excessTax, excessTax)) &&
            (identical(other.returntype, returntype) ||
                const DeepCollectionEquality()
                    .equals(other.returntype, returntype)) &&
            (identical(other.groupNmae, groupNmae) ||
                const DeepCollectionEquality()
                    .equals(other.groupNmae, groupNmae)) &&
            (identical(other.returnTime, returnTime) ||
                const DeepCollectionEquality()
                    .equals(other.returnTime, returnTime)) &&
            (identical(other.weightUomId, weightUomId) ||
                const DeepCollectionEquality()
                    .equals(other.weightUomId, weightUomId)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(
                    other.needMultipleIntegration, needMultipleIntegration) ||
                const DeepCollectionEquality().equals(
                    other.needMultipleIntegration, needMultipleIntegration)) &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality().equals(other.groupId, groupId)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(vat) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(dimension) ^
      const DeepCollectionEquality().hash(minGp) ^
      const DeepCollectionEquality().hash(avrgGp) ^
      const DeepCollectionEquality().hash(maxGp) ^
      const DeepCollectionEquality().hash(targetedGp) ^
      const DeepCollectionEquality().hash(excessTax) ^
      const DeepCollectionEquality().hash(returntype) ^
      const DeepCollectionEquality().hash(groupNmae) ^
      const DeepCollectionEquality().hash(returnTime) ^
      const DeepCollectionEquality().hash(weightUomId) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(needMultipleIntegration) ^
      const DeepCollectionEquality().hash(groupId);

  @JsonKey(ignore: true)
  @override
  _$GroupCustomDataCopyWith<_GroupCustomData> get copyWith =>
      __$GroupCustomDataCopyWithImpl<_GroupCustomData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GroupCustomDataToJson(this);
  }
}

abstract class _GroupCustomData implements GroupCustomData {
  const factory _GroupCustomData(
      {int? id,
      double? vat,
      String? code,
      Dimension? dimension,
      @JsonKey(name: "min_gp") double? minGp,
      @JsonKey(name: "avrg_gp") double? avrgGp,
      @JsonKey(name: "max_gp") double? maxGp,
      @JsonKey(name: "targeted_gp") double? targetedGp,
      @JsonKey(name: "excess_tax") double? excessTax,
      @JsonKey(name: "return_type") String? returntype,
      @JsonKey(name: "group_name") String? groupNmae,
      @JsonKey(name: "return_time") int? returnTime,
      @JsonKey(name: "weight_uom_id") int? weightUomId,
      @JsonKey(name: "is_active") bool? isActive,
      @JsonKey(name: "need_multiple_integration") bool? needMultipleIntegration,
      @JsonKey(name: "group_id") int? groupId}) = _$_GroupCustomData;

  factory _GroupCustomData.fromJson(Map<String, dynamic> json) =
      _$_GroupCustomData.fromJson;

  @override
  int? get id => throw _privateConstructorUsedError;
  @override
  double? get vat => throw _privateConstructorUsedError;
  @override
  String? get code => throw _privateConstructorUsedError;
  @override
  Dimension? get dimension => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "min_gp")
  double? get minGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "avrg_gp")
  double? get avrgGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "max_gp")
  double? get maxGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "targeted_gp")
  double? get targetedGp => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "excess_tax")
  double? get excessTax => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "return_type")
  String? get returntype => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "group_name")
  String? get groupNmae => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "return_time")
  int? get returnTime => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "weight_uom_id")
  int? get weightUomId => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "is_active")
  bool? get isActive => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "need_multiple_integration")
  bool? get needMultipleIntegration => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "group_id")
  int? get groupId => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$GroupCustomDataCopyWith<_GroupCustomData> get copyWith =>
      throw _privateConstructorUsedError;
}

Dimension _$DimensionFromJson(Map<String, dynamic> json) {
  return _Dimension.fromJson(json);
}

/// @nodoc
class _$DimensionTearOff {
  const _$DimensionTearOff();

  _Dimension call(
      {double? width, double? weight, double? length, double? height}) {
    return _Dimension(
      width: width,
      weight: weight,
      length: length,
      height: height,
    );
  }

  Dimension fromJson(Map<String, Object> json) {
    return Dimension.fromJson(json);
  }
}

/// @nodoc
const $Dimension = _$DimensionTearOff();

/// @nodoc
mixin _$Dimension {
  double? get width => throw _privateConstructorUsedError;
  double? get weight => throw _privateConstructorUsedError;
  double? get length => throw _privateConstructorUsedError;
  double? get height => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DimensionCopyWith<Dimension> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DimensionCopyWith<$Res> {
  factory $DimensionCopyWith(Dimension value, $Res Function(Dimension) then) =
      _$DimensionCopyWithImpl<$Res>;
  $Res call({double? width, double? weight, double? length, double? height});
}

/// @nodoc
class _$DimensionCopyWithImpl<$Res> implements $DimensionCopyWith<$Res> {
  _$DimensionCopyWithImpl(this._value, this._then);

  final Dimension _value;
  // ignore: unused_field
  final $Res Function(Dimension) _then;

  @override
  $Res call({
    Object? width = freezed,
    Object? weight = freezed,
    Object? length = freezed,
    Object? height = freezed,
  }) {
    return _then(_value.copyWith(
      width: width == freezed
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      weight: weight == freezed
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double?,
      length: length == freezed
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as double?,
      height: height == freezed
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
abstract class _$DimensionCopyWith<$Res> implements $DimensionCopyWith<$Res> {
  factory _$DimensionCopyWith(
          _Dimension value, $Res Function(_Dimension) then) =
      __$DimensionCopyWithImpl<$Res>;
  @override
  $Res call({double? width, double? weight, double? length, double? height});
}

/// @nodoc
class __$DimensionCopyWithImpl<$Res> extends _$DimensionCopyWithImpl<$Res>
    implements _$DimensionCopyWith<$Res> {
  __$DimensionCopyWithImpl(_Dimension _value, $Res Function(_Dimension) _then)
      : super(_value, (v) => _then(v as _Dimension));

  @override
  _Dimension get _value => super._value as _Dimension;

  @override
  $Res call({
    Object? width = freezed,
    Object? weight = freezed,
    Object? length = freezed,
    Object? height = freezed,
  }) {
    return _then(_Dimension(
      width: width == freezed
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      weight: weight == freezed
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double?,
      length: length == freezed
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as double?,
      height: height == freezed
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Dimension implements _Dimension {
  const _$_Dimension({this.width, this.weight, this.length, this.height});

  factory _$_Dimension.fromJson(Map<String, dynamic> json) =>
      _$$_DimensionFromJson(json);

  @override
  final double? width;
  @override
  final double? weight;
  @override
  final double? length;
  @override
  final double? height;

  @override
  String toString() {
    return 'Dimension(width: $width, weight: $weight, length: $length, height: $height)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Dimension &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.length, length) ||
                const DeepCollectionEquality().equals(other.length, length)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(length) ^
      const DeepCollectionEquality().hash(height);

  @JsonKey(ignore: true)
  @override
  _$DimensionCopyWith<_Dimension> get copyWith =>
      __$DimensionCopyWithImpl<_Dimension>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DimensionToJson(this);
  }
}

abstract class _Dimension implements Dimension {
  const factory _Dimension(
      {double? width,
      double? weight,
      double? length,
      double? height}) = _$_Dimension;

  factory _Dimension.fromJson(Map<String, dynamic> json) =
      _$_Dimension.fromJson;

  @override
  double? get width => throw _privateConstructorUsedError;
  @override
  double? get weight => throw _privateConstructorUsedError;
  @override
  double? get length => throw _privateConstructorUsedError;
  @override
  double? get height => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$DimensionCopyWith<_Dimension> get copyWith =>
      throw _privateConstructorUsedError;
}
